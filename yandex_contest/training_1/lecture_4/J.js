// J. Дополнительная проверка на списывание

// Ограничение времени 1 секунда
// Ограничение памяти	64Mb
// Ввод	стандартный ввод или input.txt
// Вывод стандартный вывод или output.txt

// Преподаватель курса ОиМП заказал у одного известного психолога полное психологическое обследование всех студентов,
// поступивших на ФНК с целью выяснить их склонность к списыванию еще до начала занятий и отчислить их за списывание
// еще до того как они приступят к занятиям и смогут позорить ФНК своими преступлениями.
// Психолог, привлеченный для проведения обследования, известен своим инновационным методом,
// позволяющим понять склонность к списыванию студента по наиболее часто используемому им в программах идентификатору.
// Помогите известному психологу определить, какие из студентов потенциально являются преступниками.
// Напишите программу, которая по приведенной программе выяснит наиболее часто используемый в ней идентификатор.

// Поскольку разные студенты на тестировании пишут программы на разных языках программирования,
// ваша программа должна уметь работать с произвольным языком.
// Поскольку в разных языках используются различные ключевые слова,
// то список ключевых слов в анализируемом языке предоставляется на вход программе.
// Все последовательности из латинских букв, цифр и знаков подчеркивания,
// которые не являются ключевыми словами и содержат хотя бы один символ, не являющийся цифрой,
// могут быть идентификаторами. При этом в некоторых языках идентификаторы могут начинаться с цифры,
// а в некоторых - нет. Если идентификатор не может начинаться с цифры, то последовательность,
// начинающаяся с цифры, идентификатором не является. Кроме этого, задано,
// является ли язык чувствительным к регистру символов, используемых в идентификаторах и ключевых словах.

// Формат ввода
// В первой строке вводятся число n - количество ключевых слов в языке (0 <= n <= 50) и два слова C и D,
// каждое из которых равно либо "yes", либо "no". Слово C равно "yes",
// если идентификаторы и ключевые слова в языке чувствительны к регистру символов, и "no", если нет.
// Слово D равно "yes", если идентификаторы в языке могут начинаться с цифры, и "no", если нет.

// Следующие n строк содержат по одному слову,
// состоящему из букв латинского алфавита и символов подчеркивания - ключевые слова.
// Все ключевые слова непусты, различны, при этом, если язык не чувствителен к регистру,
// то различны и без учета регистра. Длина каждого ключевого слова не превышает 50 символов.

// Далее до конца входных данных идет текст программы.
// Он содержит только символы с ASCII-кодами от 32 до 126 и переводы строки.

// Размер входных данных не превышает 10 килобайт. В программе есть хотя бы один идентификатор.

// Формат вывода
// Выведите идентификатор, встречающийся в программе максимальное число раз.
// Если таких идентификаторов несколько, следует вывести тот, который встречается в первый раз раньше.
// Если язык во входных данных не чувствителен к регистру,
// то можно выводить идентификатор в любом регистре.

// Пример 1
// Ввод	                          Вывод
// 0 yes no                       int
// int main() {
//   int a;
//   int b;
//   scanf("%d%d", &a, &b);
//   printf("%d", a + b);
// }

// Пример 2
// Ввод	                          Вывод
// 0 yes no                       d
// #define INT int
// int main() {
//   INT a, b;
//   scanf("%d%d", &a, &b);
//   printf("%d %d", a + b, 0);
// }

// Пример 3
// Ввод	                          Вывод
// 6 no no                        a
// program
// var
// begin
// end
// while
// for
// program sum;
// var
//   A, B: integer;
// begin
//   read(A, b);
//   writeln(a + b);
// end.

// Пример 4
// Ввод	                          Вывод
// 1 yes yes                      0h
// _
// a = 0h
// b = 0h
// c = 0h

const fs = require('fs');

const parseInput = (input) => {
  const [data, ...code] = input.trim().split('\n');
  let [n, C, D] = data.split(' ');
  n = Number(n);
  const caseSens = C === 'yes';
  const startWithNum = D === 'yes';

  return { n, caseSens, startWithNum, code };
};

const getWords = (str) => {
  return str.replace(/[^a-zA-Z0-9_ ]/g, ' ').split(' ').filter(Boolean);
};

const isIdentifier = (str, canStartWithNum) => {
  if (!isNaN(Number(str))) return false;

  return isNaN(Number(str[0])) || canStartWithNum;
};

const findMostCommonIdentifier = (n, caseSens, startWithNum, code) => {
  const keywords = new Set(code.slice(0, n).map((el) => !caseSens ? el.toLowerCase() : el));
  const codeLines = code.slice(n);
  const countAndPosIds = {};
  let wordCounter = 0;

  for (let line of codeLines) {
    const words = getWords(line.trim());

    for (let word of words) {
      if (!caseSens) word = word.toLowerCase();
      if (keywords.has(word)) continue;
      if (isIdentifier(word, startWithNum)) {
        wordCounter += 1;
        countAndPosIds[word] = countAndPosIds[word]
        ? [countAndPosIds[word][0] + 1, countAndPosIds[word][1]] : [1, wordCounter];
      } 
    }
  }

  let bestWord = '';
  let maxPos = [0, 0];

  for (let word in countAndPosIds) {
    if (countAndPosIds[word][0] > maxPos[0]
      || (countAndPosIds[word][0] === maxPos[0] && countAndPosIds[word][1] < maxPos[1])) {
      maxPos = countAndPosIds[word];
      bestWord = word;
    }
  }

  return bestWord;
};

const input = fs.readFileSync('input.txt', 'utf-8');
const { n, caseSens, startWithNum, code } = parseInput(input);
const mostCommonIdentifier = findMostCommonIdentifier(n, caseSens, startWithNum, code);

fs.writeFileSync('output.txt', mostCommonIdentifier);
