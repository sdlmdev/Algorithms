// G. Площадь

// Язык	Ограничение времени	Ограничение памяти	
// Все языки	0.5 секунд	64Mb	
// GNU C11 7.3	0.3 секунды	256Mb
// GNU c++ 11 4.9	0.3 секунды	256Mb
// GNU c++ 11 x32 4.9	0.3 секунды	256Mb
// GCC 5.4.0 C++14	0.3 секунды	256Mb
// GNU c++ 14 4.9	0.3 секунды	256Mb
// GNU c++17 7.3	0.3 секунды	256Mb
// GCC C++17	0.3 секунды	256Mb

// Ввод	Вывод
// стандартный ввод или input.txt	стандартный вывод или output.txt

// Городская площадь имеет размер n× m и покрыта квадратной плиткой размером 1× 1.
// При плановой замене плитки выяснилось, что новой плитки недостаточно для покрытия всей площади,
// поэтому было решено покрыть плиткой только дорожку по краю площади,
// а в центре площади разбить прямоугольную клумбу.
// При этом дорожка должна иметь одинаковую ширину по всем сторонам площади.
// Определите максимальную ширину дорожки, которую можно выложить из имеющихся плиток.

// Формат ввода
// Первая и вторая строки входных данных содержат по одному числу n и m
// (3≤ n ≤ 2× 109, 3≤ m ≤ 2× 109) — размеры площади.

// Третья строка содержит количество имеющихся плиток t, 1≤ t< nm.

// Обратите внимание, что значение t может быть больше, чем возможное значение 32-битной целочисленной переменной,
// поэтому необходимо использовать 64-битные числа (тип int64 в языке Pascal, тип long long в C и C++,
// тип long в Java и C#).

// Формат вывода
// Программа должна вывести единственное число — максимальную ширину дорожки,
// которую можно выложить из имеющихся плиток.

// Пример
// Ввод	    Вывод
// 6        2
// 7
// 38

// Примечания
// Пояснение к примеру. Площадь имеет размеры 6× 7, из 38 плиток можно выложить дорожку шириной в 2 плитки.

const checkWidth = (width, params) => {
  const [n, m, t] = params;

  return n * m - (n - 2n * width) * (m - 2n * width) <= t;
}

const binarySearch = (l, r, check, params) => {
  while (l < r) {
    const m = (l + r + 1n) / 2n;

    if (check(m, params)) {
      l = m;
    } else {
      r = m - 1n;
    }
  }

  return l;
};

const fs = require('fs');
const [n, m, t] = fs.readFileSync('input.txt', 'utf-8').trim().split('\n').map(BigInt);
const min = n < m ? n : m;

fs.writeFileSync('output.txt', binarySearch(0n, min / 2n, checkWidth, [n, m, t]).toString());