// G. Ни больше ни меньше

// Ограничение времени 2 секунды
// Ограничение памяти 256Mb
// Ввод стандартный ввод или input.txt
// Вывод стандартный вывод или output.txt

// Дан массив целых положительных чисел a длины n.
// Разбейте его на минимально возможное количество отрезков,
// чтобы каждое число было не меньше длины отрезка которому оно принадлежит.
// Длиной отрезка считается количество чисел в нем.

// Разбиение массива на отрезки считается корректным, если каждый элемент принадлежит ровно одному отрезку.

// Формат ввода
// Первая строка содержит одно целое число t (1 ≤ t ≤ 1 000) — количество наборов тестовых данных.
// Затем следуют t наборов тестовых данных.

// Первая строка набора тестовых данных содержит одно целое число n (1 ≤ n ≤ 10**5) — длину массива.

// Следующая строка содержит n целых чисел a1, a2, …, an (1 ≤ ai ≤ n) — массив a.

// Гарантируется, что сумма n по всем наборам тестовых данных не превосходит 2 ⋅ 10**5.

// Формат вывода
// Для каждого набора тестовых данных в первой строке выведите число k — количество отрезков в вашем разбиении.

// Затем в следующей строке выведите k чисел len1, len2, …, lenk — длины отрезков в порядке слева направо.

// Пример
// Ввод
// 3
// 5
// 1 3 3 3 2
// 16
// 1 9 8 7 6 7 8 9 9 9 9 9 9 9 9 9
// 7
// 7 2 3 4 3 2 7

// Вывод
// 3
// 1 2 2
// 3
// 1 6 9 
// 3
// 2 3 2 

// Примечания
// Ответы в примере соответствуют разбиениям:
// {[1], [3, 3], [3, 2]}
// {[1], [9, 8, 7, 6, 7, 8], [9, 9, 9, 9, 9, 9, 9, 9, 9]}
// {[7, 2], [3, 4, 3], [2, 7]}

// В первом наборе тестовых данных набор длин {1, 3, 1},
// соответствующий разбиению {[1], [3, 3, 3], [2]}, также был бы корректным.

const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout,
});

const getSets = (numsArr) => {
  const res = [];
  const set = [];
  let min = Infinity;

  for (let i = 0; i < numsArr.length;) {
    if (min >= set.length + 1 && numsArr[i] >= set.length + 1) {
      set.push(numsArr[i]);
      min = Math.min(min, numsArr[i]);
      i += 1;
    } else {
      res.push(set.length);
      set.length = 0;
      min = Infinity;
    }
  }

  if (set.length > 0) {
    res.push(set.length);
  }

  return res;
};

let n = 0;
let lineCnt = 0;
const res = [];

readline.on('line', (line) => {
  if (lineCnt === 0) {
    n = +line;
  } else if (lineCnt % 2 === 0) {
    const nums = line.split(' ').map(Number);
    const sets = getSets(nums);

    res.push(`${sets.length}\n${sets.join(' ')}`);
  }

  if (lineCnt === n * 2) {
    res.forEach((el) => console.log(el));
    readline.close();
  }

  lineCnt += 1;
});