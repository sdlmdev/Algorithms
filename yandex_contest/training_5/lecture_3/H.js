// H. Спички детям не игрушка!

// Ограничение времени 3 секунды
// Ограничение памяти 256Mb
// Ввод стандартный ввод или input.txt
// Вывод стандартный вывод или output.txt

// Вася любит решать головоломки со спичками.
// Чаще всего они формулируется следующим образом: дано изображение A, составленное из спичек;
// переложите в нем минимальное количество спичек так, чтобы получилось изображение B.

// Например, из номера текущего командного чемпионата школьников Санкт-Петербурга по программированию,
// можно получить ромб с диагональю, переложив всего три спички.

// Головоломки, которые решает Вася, всегда имеют решение.
// Это значит, что набор спичек, используемый в изображении A, совпадает с набором спичек,
// используемым в изображении B. Кроме того, в одном изображении никогда не встречаются две спички,
// у которых есть общий участок ненулевой длины (то есть спички могут пересекаться,
// но не могут накладываться друг на друга).

// Вася устал решать головоломки вручную, и теперь он просит вас написать, программу,
// которая будет решать головоломки за него.
// Программа будет получать описания изображений A и B и должна найти минимальное количество спичек,
// которые надо переложить в изображении A,
// чтобы полученная картинка получалась из B параллельным переносом.

// Формат ввода
// В первой строке входного файла содержится целое число n —
// количество спичек в каждом из изображений (1 ≤ n ≤ 1000).

// В следующих n строках записаны координаты концов спичек на изображении A.
// Спичка номер i описывается целыми числами x1i, y1i, x2i, y2i — координатами ее концов.
// Следующие n строк содержат описание изображения B в таком же формате.
// Набор длин этих спичек совпадает с набором длин спичек с изображения A.

// Все координаты по абсолютной величине не превосходят 10**4.
// Все спички имеют ненулевую длину, то есть x1i ≠ x2i или y1i ≠ y2i.

// Формат вывода
// Выведите в выходной файл минимальное количество спичек, которые следует переложить,
// чтобы изображение A совпало с изображением B, с точностью до параллельного переноса.

// Пример 1
// Ввод           Вывод
// 5              3
// 0 0 1 2
// 1 0 0 2
// 2 0 2 2
// 4 0 3 2
// 4 0 5 2
// 9 -1 10 1
// 10 1 9 3
// 8 1 10 1
// 8 1 9 -1
// 8 1 9 3

// Пример 2
// Ввод           Вывод
// 1              0
// 3 4 7 9
// -1 3 3 8

// Пример 3
// Ввод           Вывод
// 1              1
// -4 5 2 -3
// -12 4 -2 4

// Пример 4
// Ввод
// 1
// 10000 10000 9999 10000
// -10000 -10000 -9999 -10000

// Вывод
// 0

// Пример 5
// Ввод
// 3
// 10000 10000 -10000 -10000
// -10000 10000 -10000 -10000
// 10000 -10000 10000 10000
// -10000 -10000 10000 10000
// 10000 10000 -10000 10000
// -10000 -10000 10000 -10000

// Вывод
// 2

// Пример 6
// Ввод
// 8
// 10000 0 7071 7071
// 7071 7071 0 10000
// 0 10000 -7071 7071
// -7071 7071 -10000 0
// -10000 0 -7071 -7071
// -7071 -7071 0 -10000
// 0 -10000 7071 -7071
// 7071 -7071 10000 0
// 7071 -7071 10000 0
// 7070 -7070 9999 1
// 7069 -7069 9998 2
// 7068 -7068 9997 3
// 7067 -7067 9996 4
// 7066 -7066 9995 5
// 7065 -7065 9994 6
// 7064 -7064 9993 7

// Вывод
// 7

const checkEqual = ([x1, y1, x2, y2], [x3, y3, x4, y4]) => {
  const xA = x2 - x1;
  const yA = y2 - y1;
  const xB = x4 - x3;
  const yB = y4 - y3;
  const aSquared = xA ** 2 + yA ** 2;
  const bSquared = xB ** 2 + yB ** 2;

  if (aSquared === bSquared && ((xA * yB) - (yA * xB) === 0)) {
    return [(x2 + x1) - (x4 + x3), (y2 + y1) - (y4 + y3)];
  }

  return null;
};

const cntMin = (N, A, B) => {
  const cntMap = A.reduce((map, a) => {
    B.forEach(b => {
      const res = checkEqual(a, b);

      if (res !== null) {
        const key = res.join(',');
        map.set(key, (map.get(key) || 0) + 1);
      }
    });

    return map;
  }, new Map());

  const cntData = Array.from(cntMap.values()).sort((a, b) => b - a);

  return cntData.length > 0 ? N - cntData[0] : N;
};

const fs = require('fs');
const [[n], ...coords] = fs.readFileSync('input.txt', 'utf-8').trim().split('\n').map(
  line => line.trim().split(' ').map(Number)
);
const pointsA = coords.slice(0, n);
const pointsB = coords.slice(n);

console.log(cntMin(n, pointsA, pointsB));