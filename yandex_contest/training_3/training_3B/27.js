// 27. Вывести маршрут максимальной стоимости

// Ограничение времени 1 секунда
// Ограничение памяти	256Mb
// Ввод	стандартный ввод или input.txt
// Вывод стандартный вывод или output.txt

// В левом верхнем углу прямоугольной таблицы размером N × M находится черепашка.
// В каждой клетке таблицы записано некоторое число.
// Черепашка может перемещаться вправо или вниз,
// при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.
// Подсчитаем сумму чисел, записанных в клетках,
// через которую проползла черепашка (включая начальную и конечную клетку).
// Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

// Формат ввода
// В первой строке входных данных записаны два натуральных числа N и M,
// не превосходящих 100 — размеры таблицы. Далее идет N строк, каждая из которых содержит M чисел,
// разделенных пробелами — описание таблицы.
// Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.

// Формат вывода
// Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут,
// на котором достигается эта сумма. Маршрут выводится в виде последовательности,
// которая должна содержать N-1 букву D, означающую передвижение вниз и M-1 букву R,
// означающую передвижение направо.
// Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.

// Пример
// Ввод	                Вывод
// 5 5                  74
// 9 9 9 9 9            D D R R R R D D
// 3 0 0 0 0
// 9 9 9 9 9
// 6 6 6 6 8
// 9 9 9 9 9

const findMaxPath = (N, M, table) => {
  const dp = Array.from({ length: N }, () => Array(M).fill(0));
  const path = [];
  dp[0][0] = table[0][0]

  for (let i = 1; i < N; i += 1) {
    dp[i][0] = dp[i - 1][0] + table[i][0];
  }

  for (let j = 1; j < M; j += 1) {
    dp[0][j] = dp[0][j - 1] + table[0][j];
  }

  for (let i = 1; i < N; i += 1) {
    for (let j = 1; j < M; j += 1) {
      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + table[i][j];
    }
  }

  let i = N - 1;
  let j = M - 1;

  while (i > 0 || j > 0) {
    if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      path.push('R');
      j -= 1;
    } else {
      path.push('D');
      i -= 1;
    }
  }

  return [dp[N - 1][M - 1], path.reverse().join(' ')].join('\n');
};

const fs = require('fs');
const [[n, m], ...lines] = fs.readFileSync('input.txt', 'utf-8').trim().split('\n').map(
  line => line.trim().split(' ').map(Number)
);

console.log(findMaxPath(n, m, lines));