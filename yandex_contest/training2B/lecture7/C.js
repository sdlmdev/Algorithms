// C. Минимальное покрытие

// Ограничение времени 3 секунды
// Ограничение памяти 64Mb
// Ввод стандартный ввод или input.txt
// Вывод стандартный вывод или output.txt

// На прямой задано некоторое множество отрезков с целочисленными координатами концов [Li, Ri].
// Выберите среди данного множества подмножество отрезков, целиком покрывающее отрезок [0, M],
// (M — натуральное число), содержащее наименьшее число отрезков.

// Формат ввода
// В первой строке указана константа M (1 ≤ M ≤ 5000).
// В каждой последующей строке записана пара чисел Li и Ri (Li, Ri ≤ 50000),
// задающая координаты левого и правого концов отрезков.
// Список завершается парой нулей. Общее число отрезков не превышает 100 000.

// Формат вывода
// В первой строке выходного файла выведите минимальное число отрезков,
// необходимое для покрытия отрезка [0; M]. Далее выведите список покрывающего подмножества,
// упорядоченный по возрастанию координат левых концов отрезков.
// Список отрезков выводится в том же формате, что и во входe.
// Завершающие два нуля выводить не нужно. Если покрытие отрезка [0, M]
// исходным множеством отрезков [Li, Ri] невозможно,
// то следует вывести единственную фразу “No solution”.

// Пример 1
// Ввод      Вывод
// 1         No solution
// -1 0
// -5 -3
// 2 5
// 0 0

// Пример 2
// Ввод      Вывод
// 1         1
// -1 0      0 1
// 0 1
// 0 0

const checkSegments = (M, pointsArr) => {
  let curR = 0;
  let nextR = 0;
  let curBest = [0, 0];
  const res = [];

  for (let segment of pointsArr) {
    if (segment[0] > curR) {
      res.push(curBest);
      curR = nextR;

      if (curR >= M) break;
    }

    if (segment[0] <= curR && segment[1] > nextR) {
      curBest = segment;
      nextR = segment[1];
    }
  }

  if (curR < M) {
    curR = nextR;
    res.push(curBest);
  }

  if (curR < M) return 'No solution';

  return `${res.length}\n${res.map(seg => seg.join(' ')).join('\n')}`
};

const fs = require('fs');
let [[m], ...points] = fs.readFileSync('input.txt', 'utf-8').trim().split('\n').map(
  line => line.trim().split(' ').filter(val => val != '').map(Number)
);

points = points.filter(el => el[0] < m && el[1] > 0).sort((a, b) => a[0] - b[0] || a[1] - b[1]);

fs.writeFileSync('output.txt', checkSegments(m, points), 'utf-8');